#!/usr/bin/env python

import argparse
import itertools
import logging
import sys

sys.path.append('.')
from reqlint.analyzers.required_installed import RequiredInstalledAnalyzer
from reqlint.analyzers.required_not_installed import RequiredNotInstalledAnalyzer
from reqlint.parsers.requirements_txt import RequirementsTxtParser
from reqlint.services.pip import Pip


_logger = logging.getLogger(__name__)


class RequirementsLinter(object):
    def analyze_installed(self, requirements_txt, installed_packages):
        analyzer = RequiredInstalledAnalyzer(
            requirements_txt=requirements_txt,
            installed_packages=installed_packages,
        )
        advice_list = analyzer.analyze()
        return advice_list

    def analyze_not_installed(self, requirements_txt, installed_packages):
        analyzer = RequiredNotInstalledAnalyzer(
            requirements_txt=requirements_txt,
            installed_packages=installed_packages,
        )
        advice_list = analyzer.analyze()
        return advice_list

    def analyze(self, requirements_txt, pip_path):
        # gather all the data we need to analyze
        parser = RequirementsTxtParser(fileobj=open(requirements_txt))
        requirements_txt = parser.parse()

        pip = Pip(pip_path=pip_path)
        installed_packages = pip.list_installed_packages()

        # run the analyzers
        advice_list1 = self.analyze_installed(requirements_txt, installed_packages)
        advice_list2 = self.analyze_not_installed(requirements_txt, installed_packages)
        advice_lists = [
            advice_list1,
            advice_list2,
        ]

        advice_all = itertools.chain(
            *(ad_list.advice_list for ad_list in advice_lists)
        )

        # display all advice
        for advice in advice_all:
            print(advice.format_display_line())

        # if we have any warnings or errors then exit with error
        if any((ad_list.has_problems() for ad_list in advice_lists)):
            return 1

        return 0

    def run(self, args):
        print('Using pip: %s' % args.pip_path)
        print('Using requirements.txt: %s' % args.requirements_txt)

        exit_code = self.analyze(
            requirements_txt=args.requirements_txt,
            pip_path=args.pip_path,
        )

        return exit_code


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description=(
            'Linter for requirements.txt\n'
            '\n'
            'To see if all requirements are installed:\n'
            '  reqlint -r requirements.txt --pip /path/to/venv/bin/pip'
        ),
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument('--pip', dest='pip_path', metavar='<pip>',
                        help='Path to pip program (typically in a virtualenv)')
    parser.add_argument('-r', '--requirements', dest='requirements_txt',
                        metavar='<file>',
                        help='Path to requirements.txt file')
    parser.add_argument('-v', '--verbose', dest='verbose', action='store_true',
                        help='Run in verbose mode')
    args = parser.parse_args()

    logging.basicConfig(
        level=logging.DEBUG if args.verbose else logging.WARN,
        format='[%(levelname)s] %(name)s %(message)s',
    )

    if not all((args.pip_path, args.requirements_txt)):
        parser.print_help()
        sys.exit(2)

    linter = RequirementsLinter()
    exit_code = linter.run(args)
    sys.exit(exit_code)
